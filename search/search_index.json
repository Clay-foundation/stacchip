{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"stacchip","text":"<p>Dynamically create image chips for eath observation machine learning applications using a custom chip index based on STAC items.</p> <p>Get a STAC item, index its contents, and create chips dynamically like so</p> <pre><code># Get item from an existing STAC catalog\nitem = stac.search(...)\n\n# Index all chips that could be derived from the STAC item\nindex = Indexer(item).create_index()\n\n# Use the index to get RGB array for a specific chip\nchip = Chipper(index).chip(x=23, y=42)\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<p>Stacchip is available on pypi</p> <pre><code>pip install stacchip\n</code></pre>"},{"location":"#overview","title":"Overview","text":"<p>Stacchip relies on three cloud oriented technologies. Cloud Optimized Geotiffs (COG), Spatio Temporal Asset Catalogs (STAC), and GeoParquet. Instead of pre-creating millions of files of a fixed size, chips are indexed first in tables, and then created dynamically from the index files when needed. The imagery data itsel is kept in its original format and referenced in STAC items.</p> <p>Creating chips with stacchip is composed of two steps:</p> <ol> <li>Create a stacchip index from a set of STAC</li> <li>Dynamically create pixel arrays for any chip in the stacchip index</li> </ol> <p>Indexes can be created separately for different imagery sources, and combined into larger indexes when needed. This makes mixing different imagery sources simple, and allows for flexibility during the modeling process, as imagery sources can be added and removed by only updating the combined index.</p> <p>The mechanism is purposefully kept as generic as possible. The index creation is done based on a STAC item alone, no other input is needed. Obtaining image data for a chip that is registered in a stacchip index only requires a few lines of code.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>Remote sensing imagery is typically distributed in large files (scenes) that typically have the order of 10 thousand of pixels in both the x and y directions. This is true for systems like Landsat, Sentinel 1 and 2, and aerial imagery such as NAIP.</p> <p>Machine learning models operate on much smaller image sizes. Many use 256x256 pixels, and the largest inputs are in the range of 1000 pixels.</p> <p>This poses a challenge to modelers, as they have to cut the larger scenes into pieces before passing them to their models. The smaller image snippets are typically referred to as \"chips\". A term we will use throughout this documentation.</p> <p>Creating imagery chips tends to be a tedious and slow process, and it is specific for each model. Models will have different requirements on image sizes, datatypes, and the spectral bands to include. A set of chips that works for one model might be useless for the next.</p> <p>Systemizing how chips are tracked, and making the chip creation more dynamic is a way to work around these difficulties. This is the goal fo stacchip. It presents an approach that leverages cloud optimized technology to make chipping simpler, faster, and less static.</p>"},{"location":"#license","title":"License","text":"<p>This repository is released under an Apache 2.0 license. For more details see LICENSE</p>"},{"location":"chipper/","title":"Chipper","text":"<p>The Chipper class can be used to create chips based on an existing stacchip index.</p> <p>The chipper class takes as input an Indexer class object. The indexer class can be instantiated using the <code>load_indexer_s3</code> and <code>load_indexer_local</code> utils functions for indexes that have been previously created using stacchip processors.</p> <p>For local stacchip indexes, the mountpath can be passed. Asset links in the STAC items are then patched with the local mountpath.</p> <p>The chipper also has an <code>asset_blacklist</code> argument that allows skipping assets from the chip retrieval process. This can be used to exclude unnecessary assets and through that increase loading speed.</p> <p>The following code snippet gives an example using a local path.</p> <pre><code>import geoarrow.pyarrow.dataset as gads\n\nfrom stacchip.chipper import Chipper\nfrom stacchip.utils import load_indexer_s3\n\n# Load a stacchip index table\ndataset = gads.dataset(\"/path/to/parquet/index\", format=\"parquet\")\ntable = dataset.to_table()\n\n# Use util to load indexer using data from a \n# remote S3 bucket.\nindexer = load_indexer_s3(\n    bucket=\"clay-v1-data\",\n    platform=table.column(\"platform\")[row],\n    item_id = table.column(\"item\")[row],\n)\n\n# Instantiate chipper\nchipper = Chipper(indexer)\n\n# Get data for a single chip as registered\n# in row 42 of the index.\nrow = 42\nchip_index_x = table.column(\"chip_index_x\")[row].as_py()\nchip_index_y = table.column(\"chip_index_y\")[row].as_py()\ndata = chipper.chip(chip_index_x, chip_index_y)\n</code></pre>"},{"location":"indexer/","title":"Indexer","text":"<p>The Indexer class is build to create a chip index for data registered in a a STAC item. The indexer will calculate the number of available chips in a STAC item given a chip size. The resulting chip index is stored as a geoparquet table.</p> <p>The following example creates an index the Landsat-9 STAC item from the tests</p> <pre><code>from pystac import Item\nfrom stacchip.indexer import LandsatIndexer\n\nitem = Item.from_file(\n    \"tests/data/landsat-c2l2-sr-LC09_L2SR_086107_20240311_20240312_02_T2_SR.json\"\n)\nindexer = LandsatIndexer(item)\nindex = indexer.create_index()\n</code></pre>"},{"location":"indexer/#nodata-and-cloud-coverage","title":"Nodata and cloud coverage","text":"<p>Earth observation data often comes in scenes that contain nodata pixels, and the imagery might contain clouds. Statistics on nodata and cloud cover is  relevant information for model training. Typically a model is trained with limited amounts nodata and cloud pixels.</p> <p>The indexer therefore needs to be track these two variables so that the modeler can choose how much or how little nodata pixels and cloudy pixels should be passed to the model. However, how this information is stored varies for different image sources.</p> <p>The indexer class might need adaption for new data sources. In these cases, the base class has to be subclassed and the <code>get_stats</code> method overridden to produce the right statistics.</p> <p>The stacchip library has a generic indexer for sources that have neither nodata or cloudy pixels in them. It has one indexer that takes a nodata mask as input, but assumes that there are no cloudy pixels (useful for sentinel-1). It also contains specific indexers for Landsat and Sentinel-2. For more information consult the reference documentation.</p>"},{"location":"indexer/#merging-indexes","title":"Merging indexes","text":"<p>Stacchip indexes are geoparquet tables, and as such they can be merged quite easily in to a single table. The recommendation is to store each stacchip index for a single STAC item in a subfolder, then the files can be merged and the  STAC item can be tracked using the folder structure using partitioning feature from pyarrow.</p> <p>The following example assumes that each index file from a single STAC item is in a subfolder that is named after the STAC item id.</p> <pre><code>from pyarrow import dataset as ds\n\npart = ds.partitioning(field_names=[\"item_id\"])\ndata = ds.dataset(\n    \"/path/to/stacchip/indices\",\n    format=\"parquet\",\n    partitioning=part,\n)\nds.write_dataset(\n    data,\n    \"/path/to/combined-index\",\n    format=\"parquet\",\n)\n</code></pre>"},{"location":"naip-tutorial/","title":"Tutorial","text":"<p>The following code example shows how to obtain RGB+NIR chips from NAIP imagery and plot them.</p> <pre><code>import random\n\nimport pystac_client\nfrom stacchip.indexer import NoStatsChipIndexer\nfrom stacchip.chipper import Chipper\nimport os\nimport matplotlib.pyplot as plt\n\n# Optimize GDAL settings for cloud optimized reading\nos.environ[\"GDAL_DISABLE_READDIR_ON_OPEN\"] = \"EMPTY_DIR\"\nos.environ[\"AWS_REQUEST_PAYER\"] = \"requester\"\n\n# Query STAC catalog for NAIP data\ncatalog = pystac_client.Client.open(\"https://earth-search.aws.element84.com/v1\")\n\n\nitems = catalog.search(\n    collections=[\"naip\"],\n    max_items=100,\n)\n\nitems = items.item_collection()\n\nitems_list = list(items)\nrandom.shuffle(items_list)\n\nchips = []\nfor item in items_list[:10]:\n    print(f\"Working on {item}\")\n\n    # Index the chips in the item\n    indexer = NoStatsChipIndexer(item)\n\n    # Instanciate the chipper\n    chipper = Chipper(indexer, assets=[\"image\"])\n\n    # Get first chip for the \"image\" asset key\n    for chip_id in random.sample(range(0, len(chipper)), 5):\n        x_index, y_index, chip = chipper[chip_id]\n        chips.append(chip[\"image\"])\n\n\nfig, axs = plt.subplots(5, 10, gridspec_kw={'wspace': 0.01, 'hspace': 0.01}, squeeze=True)\n\nfor idx, ax in enumerate(axs.flatten()):\n    chip = chips[idx]\n    # Visualize the data\n    ax.imshow(chip[:3].swapaxes(0, 1).swapaxes(1, 2))\n\nplt.tight_layout()\nplt.show()\n</code></pre> <p>Resutling in the following plot</p> <p></p>"},{"location":"processors/","title":"Processors","text":"<p>To use stacchip for an existing imagery archive, the indexes need to be created for each scene or STAC item.</p> <p>Stacchip comes with processors that can be used to collect and index imagery from multiple data sources. This will be extended as the package grows. </p> <p>Each processor is registered as a command line utility so that it can be scaled easily. Note that these processors are created to work well with AWS Batch, but are not dependent on it and can  be used otherwise too.</p>"},{"location":"processors/#sentinel-2","title":"Sentinel-2","text":"<p>The <code>stacchip-sentinel-2</code> processor CLi command processes Sentinel-2 data. It will process MGRS tiles from a list of tiles from a layer that can be opened by geopandas.</p> <p>Each MGRS tile will be processed by the row index in the source file.</p> <p>For each tile it will process the least cloudy image in each quartal from two random years between 2018 and 2023.</p> <p>The script uses environment variables to determine all inputs:</p> <ol> <li>The index of the MGRS tile to be processes from the source file</li> <li>The source file for the MGRS tile sample</li> <li>A target bucket for writing the assets, stac items, and stacchip index.</li> </ol> <p>An example set of environment variables to run this script is:</p> <pre><code>export AWS_BATCH_JOB_ARRAY_INDEX=0\nexport STACCHIP_MGRS_SOURCE=https://clay-mgrs-samples.s3.amazonaws.com/mgrs_sample_v02.fgb\nexport STACCHIP_BUCKET=clay-v1-data\n</code></pre>"},{"location":"processors/#landsat","title":"Landsat","text":"<p>The <code>stacchip-landsat</code> processor CLI command processes Landsat data. It will process a list of geometries from a layer that can be opened by geopandas. For each row, it will use the centroid of the geometry to search for landsat scenes.</p> <p>For each geometry it will process the least cloudy image in each quartal from two random years between 2018 and 2023. For one year it will collect L1 data, and for the other year L2 data. The platform is either Landsat-8 or Landsat-9, depending on availability and cloud cover.</p> <p>The script uses environment variables to determine all inputs:</p> <ol> <li>The index of geometry to be processes from the source file</li> <li>The source file for the source sample file</li> <li>A target bucket for writing the assets, stac items, and stacchip index.</li> </ol> <p>An example set of environment variables to run this script is:</p> <pre><code>export AWS_BATCH_JOB_ARRAY_INDEX=0\nexport STACCHIP_SAMPLE_SOURCE=https://clay-mgrs-samples.s3.amazonaws.com/mgrs_sample_v02.fgb\nexport STACCHIP_BUCKET=clay-v1-data\n</code></pre>"},{"location":"processors/#naip","title":"NAIP","text":"<p>The <code>stacchip-naip</code> processor CLI command processes imagery from the National Imagery Program (NAIP).</p> <p>The sample locations were created using the Natural Earth database as a source. The sample includes all popluated places, protected areas and parks, airports, and ports. In addition, we sampled one random point  along each river, and one random location within each lake that is registered in Natural Earth. Finally, we sampled 4000 random points. All data was  filtered to be within the CONUS region.</p> <p>Similar to the other processors, the input variables are provided using env vars.</p> <p>An example set of environment variables to run this script is:</p> <pre><code>export AWS_BATCH_JOB_ARRAY_INDEX=0\nexport STACCHIP_SAMPLE_SOURCE=https://clay-mgrs-samples.s3.amazonaws.com/clay_v1_naip_sample_natural_earth.fgb\nexport STACCHIP_BUCKET=clay-v1-data\n</code></pre>"},{"location":"processors/#linz","title":"LINZ","text":"<p>The <code>stacchip-linz</code> processor CLI processes data from the New Zealand high resolution open aerial imagery.</p> <p>As a sample, we randomly select 50% the scenes, whith a minimum of 10 and a maximum of 2000 scenes for each catalog that was included. We selected the latest imagery for each of the available regions of new zealand. The list of catalogs is in the linz processor file.</p> <p>We also resample all the imagery to 30cm so that the data is consistent.</p> <p>Similar to the other processors, the input variables are provided using env vars.</p> <p>An example set of environment variables to run this script is:</p> <pre><code>export AWS_BATCH_JOB_ARRAY_INDEX=0\nexport STACCHIP_BUCKET=clay-v1-data\n</code></pre>"},{"location":"processors/#modis","title":"MODIS","text":"<p>The <code>stacchip-modis</code> processor CLI processes data from the MODIS archive. The modis scenes are reprojected to the web mercator projection, and stored in S3. Then the indexer will create one index table per modis scene. We use 233 modis SIN grid tiles, with 4 random dates of 4 years of data for each SIN grid tile.</p> <p>Similar to the other processors, the input variables are provided using env vars.</p> <p>An example set of environment variables to run this script is:</p> <pre><code>export AWS_BATCH_JOB_ARRAY_INDEX=0\nexport STACCHIP_BUCKET=clay-v1-data\n</code></pre>"},{"location":"processors/#batch-processing","title":"Batch processing","text":"<p>The following base image can be used for batch processing. Installing the package will include the command line utilities for each processor.</p> <pre><code>FROM python:3.11\n\nRUN pip install stacchip\n</code></pre>"},{"location":"processors/#prechip","title":"Prechip","text":"<p>In cases where chips need to be computed in advance, the <code>stacchip-prechip</code> cli script is a helper to create npz files from the chips.</p>"},{"location":"api/stacchip/chipper/","title":"Module stacchip.chipper","text":""},{"location":"api/stacchip/chipper/#classes","title":"Classes","text":""},{"location":"api/stacchip/chipper/#chipper","title":"Chipper","text":"<pre><code>class Chipper(\n    indexer: stacchip.indexer.ChipIndexer,\n    mountpath: Optional[str] = None,\n    assets: Optional[List[str]] = None,\n    asset_blacklist: Optional[List[str]] = None\n)\n</code></pre> <p>Chipper class for managing and processing raster data chips.</p>"},{"location":"api/stacchip/chipper/#methods","title":"Methods","text":""},{"location":"api/stacchip/chipper/#chip","title":"chip","text":"<pre><code>def chip(\n    self,\n    x: int,\n    y: int\n) -&gt; dict\n</code></pre> <p>Retrieves chip pixel array for the specified x and y index numbers.</p> <p>Parameters:</p> Name Type Description Default x int The x index of the chip. None y int The y index of the chip. None <p>Returns:</p> Type Description dict A dictionary where keys are asset names and values are arrays of pixel values."},{"location":"api/stacchip/chipper/#get_pixels_for_asset","title":"get_pixels_for_asset","text":"<pre><code>def get_pixels_for_asset(\n    self,\n    key: str,\n    x: int,\n    y: int\n) -&gt; Union[numpy._typing._array_like._SupportsArray[numpy.dtype[Any]], numpy._typing._nested_sequence._NestedSequence[numpy._typing._array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy._typing._nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]]\n</code></pre> <p>Extracts chip pixel values for one asset.</p> <p>Parameters:</p> Name Type Description Default key str The asset key to extract pixels from. None x int The x index of the chip. None y int The y index of the chip. None <p>Returns:</p> Type Description ArrayLike Array of pixel values for the specified asset. <p>Raises:</p> Type Description ValueError If asset dimensions are not multiples of the highest resolution dimensions."},{"location":"api/stacchip/indexer/","title":"Module stacchip.indexer","text":""},{"location":"api/stacchip/indexer/#classes","title":"Classes","text":""},{"location":"api/stacchip/indexer/#chipindexer","title":"ChipIndexer","text":"<pre><code>class ChipIndexer(\n    item: pystac.item.Item,\n    chip_size: int = 256,\n    chip_max_nodata: float = 0.5,\n    shape=None\n)\n</code></pre> <p>Indexer base class</p>"},{"location":"api/stacchip/indexer/#descendants","title":"Descendants","text":"<ul> <li>stacchip.indexer.NoStatsChipIndexer</li> <li>stacchip.indexer.NoDataMaskChipIndexer</li> <li>stacchip.indexer.LandsatIndexer</li> <li>stacchip.indexer.Sentinel2Indexer</li> <li>stacchip.indexer.ModisIndexer</li> </ul>"},{"location":"api/stacchip/indexer/#instance-variables","title":"Instance variables","text":"<pre><code>bbox\n</code></pre> <p>Bounding box that covers all tiles</p> <p>This is different from the bounding box of the STAC item if the tiles don't fit into the number of pixels perfectly.</p> <pre><code>crs\n</code></pre> <p>Get coordinate reference system for the assets in this index</p> <pre><code>size\n</code></pre> <p>Number of tiles in this STAC item</p> <pre><code>x_size\n</code></pre> <p>Number of tiles vailable in x direction</p> <pre><code>y_size\n</code></pre> <p>Number of tiles vailable in y direction</p>"},{"location":"api/stacchip/indexer/#methods","title":"Methods","text":""},{"location":"api/stacchip/indexer/#assert_units_metre","title":"assert_units_metre","text":"<pre><code>def assert_units_metre(\n    self\n) -&gt; None\n</code></pre> <p>Ensure input data has meters as units</p>"},{"location":"api/stacchip/indexer/#create_index","title":"create_index","text":"<pre><code>def create_index(\n    self\n) -&gt; pyarrow.lib.Table\n</code></pre> <p>The index for this STAC item</p>"},{"location":"api/stacchip/indexer/#get_chip_bbox","title":"get_chip_bbox","text":"<pre><code>def get_chip_bbox(\n    self,\n    x: int,\n    y: int\n) -&gt; shapely.geometry.polygon.Polygon\n</code></pre> <p>Bounding box for a chip</p>"},{"location":"api/stacchip/indexer/#get_stats","title":"get_stats","text":"<pre><code>def get_stats(\n    self,\n    x: int,\n    y: int\n) -&gt; Tuple[float, float]\n</code></pre> <p>A function to write for each indexer that returns nodata and</p> <p>cloud statistics for a chip</p>"},{"location":"api/stacchip/indexer/#reproject","title":"reproject","text":"<pre><code>def reproject(\n    self,\n    geom\n) -&gt; shapely._geometry.GeometryType\n</code></pre> <p>Reproject a geometry into WGS84</p>"},{"location":"api/stacchip/indexer/#setup_projector","title":"setup_projector","text":"<pre><code>def setup_projector(\n    self\n)\n</code></pre> <p>Prepare projection function to project geometries into WGS84</p>"},{"location":"api/stacchip/indexer/#shape","title":"shape","text":"<pre><code>def shape(\n    ...\n)\n</code></pre> <p>Shape of the STAC item data</p> <p>Obtains the shape of the highest resolution band from all the available bands.</p>"},{"location":"api/stacchip/indexer/#transform","title":"transform","text":"<pre><code>def transform(\n    ...\n)\n</code></pre> <p>The transform property from the STAC item</p>"},{"location":"api/stacchip/indexer/#landsatindexer","title":"LandsatIndexer","text":"<pre><code>class LandsatIndexer(\n    item: pystac.item.Item,\n    chip_size: int = 256,\n    chip_max_nodata: float = 0.5,\n    shape=None\n)\n</code></pre> <p>Chip indexer for Landsat 8 and 9 STAC items</p>"},{"location":"api/stacchip/indexer/#ancestors-in-mro","title":"Ancestors (in MRO)","text":"<ul> <li>stacchip.indexer.ChipIndexer</li> </ul>"},{"location":"api/stacchip/indexer/#instance-variables_1","title":"Instance variables","text":"<pre><code>bbox\n</code></pre> <p>Bounding box that covers all tiles</p> <p>This is different from the bounding box of the STAC item if the tiles don't fit into the number of pixels perfectly.</p> <pre><code>crs\n</code></pre> <p>Get coordinate reference system for the assets in this index</p> <pre><code>size\n</code></pre> <p>Number of tiles in this STAC item</p> <pre><code>x_size\n</code></pre> <p>Number of tiles vailable in x direction</p> <pre><code>y_size\n</code></pre> <p>Number of tiles vailable in y direction</p>"},{"location":"api/stacchip/indexer/#methods_1","title":"Methods","text":""},{"location":"api/stacchip/indexer/#assert_units_metre_1","title":"assert_units_metre","text":"<pre><code>def assert_units_metre(\n    self\n) -&gt; None\n</code></pre> <p>Ensure input data has meters as units</p>"},{"location":"api/stacchip/indexer/#create_index_1","title":"create_index","text":"<pre><code>def create_index(\n    self\n) -&gt; pyarrow.lib.Table\n</code></pre> <p>The index for this STAC item</p>"},{"location":"api/stacchip/indexer/#get_chip_bbox_1","title":"get_chip_bbox","text":"<pre><code>def get_chip_bbox(\n    self,\n    x: int,\n    y: int\n) -&gt; shapely.geometry.polygon.Polygon\n</code></pre> <p>Bounding box for a chip</p>"},{"location":"api/stacchip/indexer/#get_stats_1","title":"get_stats","text":"<pre><code>def get_stats(\n    self,\n    x: int,\n    y: int\n) -&gt; Tuple[float, float]\n</code></pre> <p>Cloud and nodata percentage for a chip</p> <p>Uses the qa band to compute these values.</p>"},{"location":"api/stacchip/indexer/#qa","title":"qa","text":"<pre><code>def qa(\n    ...\n)\n</code></pre> <p>The quality band data for the STAC item</p>"},{"location":"api/stacchip/indexer/#reproject_1","title":"reproject","text":"<pre><code>def reproject(\n    self,\n    geom\n) -&gt; shapely._geometry.GeometryType\n</code></pre> <p>Reproject a geometry into WGS84</p>"},{"location":"api/stacchip/indexer/#setup_projector_1","title":"setup_projector","text":"<pre><code>def setup_projector(\n    self\n)\n</code></pre> <p>Prepare projection function to project geometries into WGS84</p>"},{"location":"api/stacchip/indexer/#shape_1","title":"shape","text":"<pre><code>def shape(\n    ...\n)\n</code></pre> <p>Shape of the STAC item data</p> <p>Obtains the shape of the highest resolution band from all the available bands.</p>"},{"location":"api/stacchip/indexer/#transform_1","title":"transform","text":"<pre><code>def transform(\n    ...\n)\n</code></pre> <p>The transform property from the STAC item</p>"},{"location":"api/stacchip/indexer/#modisindexer","title":"ModisIndexer","text":"<pre><code>class ModisIndexer(\n    item: pystac.item.Item,\n    chip_size: int = 256,\n    chip_max_nodata: float = 0.5,\n    shape=None\n)\n</code></pre> <p>Indexer for MODIS STAC items</p>"},{"location":"api/stacchip/indexer/#ancestors-in-mro_1","title":"Ancestors (in MRO)","text":"<ul> <li>stacchip.indexer.ChipIndexer</li> </ul>"},{"location":"api/stacchip/indexer/#instance-variables_2","title":"Instance variables","text":"<pre><code>bbox\n</code></pre> <p>Bounding box that covers all tiles</p> <p>This is different from the bounding box of the STAC item if the tiles don't fit into the number of pixels perfectly.</p> <pre><code>crs\n</code></pre> <p>Get coordinate reference system for the assets in this index</p> <pre><code>size\n</code></pre> <p>Number of tiles in this STAC item</p> <pre><code>x_size\n</code></pre> <p>Number of tiles vailable in x direction</p> <pre><code>y_size\n</code></pre> <p>Number of tiles vailable in y direction</p>"},{"location":"api/stacchip/indexer/#methods_2","title":"Methods","text":""},{"location":"api/stacchip/indexer/#assert_units_metre_2","title":"assert_units_metre","text":"<pre><code>def assert_units_metre(\n    self\n) -&gt; None\n</code></pre> <p>Ensure input data has meters as units</p>"},{"location":"api/stacchip/indexer/#create_index_2","title":"create_index","text":"<pre><code>def create_index(\n    self\n) -&gt; pyarrow.lib.Table\n</code></pre> <p>The index for this STAC item</p>"},{"location":"api/stacchip/indexer/#get_chip_bbox_2","title":"get_chip_bbox","text":"<pre><code>def get_chip_bbox(\n    self,\n    x: int,\n    y: int\n) -&gt; shapely.geometry.polygon.Polygon\n</code></pre> <p>Bounding box for a chip</p>"},{"location":"api/stacchip/indexer/#get_stats_2","title":"get_stats","text":"<pre><code>def get_stats(\n    self,\n    x: int,\n    y: int\n) -&gt; Tuple[float, float]\n</code></pre> <p>Cloud and nodata percentage for a chip</p>"},{"location":"api/stacchip/indexer/#quality","title":"quality","text":"<pre><code>def quality(\n    ...\n)\n</code></pre> <p>The Quality band data for the STAC item</p>"},{"location":"api/stacchip/indexer/#reproject_2","title":"reproject","text":"<pre><code>def reproject(\n    self,\n    geom\n) -&gt; shapely._geometry.GeometryType\n</code></pre> <p>Reproject a geometry into WGS84</p>"},{"location":"api/stacchip/indexer/#setup_projector_2","title":"setup_projector","text":"<pre><code>def setup_projector(\n    self\n)\n</code></pre> <p>Prepare projection function to project geometries into WGS84</p>"},{"location":"api/stacchip/indexer/#shape_2","title":"shape","text":"<pre><code>def shape(\n    ...\n)\n</code></pre> <p>Shape of the STAC item data</p> <p>Obtains the shape of the highest resolution band from all the available bands.</p>"},{"location":"api/stacchip/indexer/#transform_2","title":"transform","text":"<pre><code>def transform(\n    ...\n)\n</code></pre> <p>The transform property from the STAC item</p>"},{"location":"api/stacchip/indexer/#nodatamaskchipindexer","title":"NoDataMaskChipIndexer","text":"<pre><code>class NoDataMaskChipIndexer(\n    item: pystac.item.Item,\n    nodata_mask: Union[numpy._typing._array_like._SupportsArray[numpy.dtype[Any]], numpy._typing._nested_sequence._NestedSequence[numpy._typing._array_like._SupportsArray[numpy.dtype[Any]]], bool, int, float, complex, str, bytes, numpy._typing._nested_sequence._NestedSequence[Union[bool, int, float, complex, str, bytes]]],\n    chip_size: int = 256,\n    chip_max_nodata: float = 0.5\n)\n</code></pre> <p>Chip indexer that takes the nodata mask as input and assumes that</p> <p>there are no clouds in the image</p>"},{"location":"api/stacchip/indexer/#ancestors-in-mro_2","title":"Ancestors (in MRO)","text":"<ul> <li>stacchip.indexer.ChipIndexer</li> </ul>"},{"location":"api/stacchip/indexer/#instance-variables_3","title":"Instance variables","text":"<pre><code>bbox\n</code></pre> <p>Bounding box that covers all tiles</p> <p>This is different from the bounding box of the STAC item if the tiles don't fit into the number of pixels perfectly.</p> <pre><code>crs\n</code></pre> <p>Get coordinate reference system for the assets in this index</p> <pre><code>size\n</code></pre> <p>Number of tiles in this STAC item</p> <pre><code>x_size\n</code></pre> <p>Number of tiles vailable in x direction</p> <pre><code>y_size\n</code></pre> <p>Number of tiles vailable in y direction</p>"},{"location":"api/stacchip/indexer/#methods_3","title":"Methods","text":""},{"location":"api/stacchip/indexer/#assert_units_metre_3","title":"assert_units_metre","text":"<pre><code>def assert_units_metre(\n    self\n) -&gt; None\n</code></pre> <p>Ensure input data has meters as units</p>"},{"location":"api/stacchip/indexer/#create_index_3","title":"create_index","text":"<pre><code>def create_index(\n    self\n) -&gt; pyarrow.lib.Table\n</code></pre> <p>The index for this STAC item</p>"},{"location":"api/stacchip/indexer/#get_chip_bbox_3","title":"get_chip_bbox","text":"<pre><code>def get_chip_bbox(\n    self,\n    x: int,\n    y: int\n) -&gt; shapely.geometry.polygon.Polygon\n</code></pre> <p>Bounding box for a chip</p>"},{"location":"api/stacchip/indexer/#get_stats_3","title":"get_stats","text":"<pre><code>def get_stats(\n    self,\n    x: int,\n    y: int\n) -&gt; Tuple[float, float]\n</code></pre> <p>Cloud and nodata percentage for a chip</p> <p>Assumes there are no cloudy pixels and computes nodata from mask</p>"},{"location":"api/stacchip/indexer/#reproject_3","title":"reproject","text":"<pre><code>def reproject(\n    self,\n    geom\n) -&gt; shapely._geometry.GeometryType\n</code></pre> <p>Reproject a geometry into WGS84</p>"},{"location":"api/stacchip/indexer/#setup_projector_3","title":"setup_projector","text":"<pre><code>def setup_projector(\n    self\n)\n</code></pre> <p>Prepare projection function to project geometries into WGS84</p>"},{"location":"api/stacchip/indexer/#shape_3","title":"shape","text":"<pre><code>def shape(\n    ...\n)\n</code></pre> <p>Shape of the STAC item data</p> <p>Obtains the shape of the highest resolution band from all the available bands.</p>"},{"location":"api/stacchip/indexer/#transform_3","title":"transform","text":"<pre><code>def transform(\n    ...\n)\n</code></pre> <p>The transform property from the STAC item</p>"},{"location":"api/stacchip/indexer/#nostatschipindexer","title":"NoStatsChipIndexer","text":"<pre><code>class NoStatsChipIndexer(\n    item: pystac.item.Item,\n    chip_size: int = 256,\n    chip_max_nodata: float = 0.5,\n    shape=None\n)\n</code></pre> <p>Indexer that assumes that none of the chips have any clouds or nodata</p>"},{"location":"api/stacchip/indexer/#ancestors-in-mro_3","title":"Ancestors (in MRO)","text":"<ul> <li>stacchip.indexer.ChipIndexer</li> </ul>"},{"location":"api/stacchip/indexer/#instance-variables_4","title":"Instance variables","text":"<pre><code>bbox\n</code></pre> <p>Bounding box that covers all tiles</p> <p>This is different from the bounding box of the STAC item if the tiles don't fit into the number of pixels perfectly.</p> <pre><code>crs\n</code></pre> <p>Get coordinate reference system for the assets in this index</p> <pre><code>size\n</code></pre> <p>Number of tiles in this STAC item</p> <pre><code>x_size\n</code></pre> <p>Number of tiles vailable in x direction</p> <pre><code>y_size\n</code></pre> <p>Number of tiles vailable in y direction</p>"},{"location":"api/stacchip/indexer/#methods_4","title":"Methods","text":""},{"location":"api/stacchip/indexer/#assert_units_metre_4","title":"assert_units_metre","text":"<pre><code>def assert_units_metre(\n    self\n) -&gt; None\n</code></pre> <p>Ensure input data has meters as units</p>"},{"location":"api/stacchip/indexer/#create_index_4","title":"create_index","text":"<pre><code>def create_index(\n    self\n) -&gt; pyarrow.lib.Table\n</code></pre> <p>The index for this STAC item</p>"},{"location":"api/stacchip/indexer/#get_chip_bbox_4","title":"get_chip_bbox","text":"<pre><code>def get_chip_bbox(\n    self,\n    x: int,\n    y: int\n) -&gt; shapely.geometry.polygon.Polygon\n</code></pre> <p>Bounding box for a chip</p>"},{"location":"api/stacchip/indexer/#get_stats_4","title":"get_stats","text":"<pre><code>def get_stats(\n    self,\n    x: int,\n    y: int\n) -&gt; Tuple[float, float]\n</code></pre> <p>Cloud and nodata percentage for a chip</p>"},{"location":"api/stacchip/indexer/#reproject_4","title":"reproject","text":"<pre><code>def reproject(\n    self,\n    geom\n) -&gt; shapely._geometry.GeometryType\n</code></pre> <p>Reproject a geometry into WGS84</p>"},{"location":"api/stacchip/indexer/#setup_projector_4","title":"setup_projector","text":"<pre><code>def setup_projector(\n    self\n)\n</code></pre> <p>Prepare projection function to project geometries into WGS84</p>"},{"location":"api/stacchip/indexer/#shape_4","title":"shape","text":"<pre><code>def shape(\n    ...\n)\n</code></pre> <p>Shape of the STAC item data</p> <p>Obtains the shape of the highest resolution band from all the available bands.</p>"},{"location":"api/stacchip/indexer/#transform_4","title":"transform","text":"<pre><code>def transform(\n    ...\n)\n</code></pre> <p>The transform property from the STAC item</p>"},{"location":"api/stacchip/indexer/#sentinel2indexer","title":"Sentinel2Indexer","text":"<pre><code>class Sentinel2Indexer(\n    item: pystac.item.Item,\n    chip_size: int = 256,\n    chip_max_nodata: float = 0.5,\n    shape=None\n)\n</code></pre> <p>Indexer for Sentinel-2 STAC items</p>"},{"location":"api/stacchip/indexer/#ancestors-in-mro_4","title":"Ancestors (in MRO)","text":"<ul> <li>stacchip.indexer.ChipIndexer</li> </ul>"},{"location":"api/stacchip/indexer/#class-variables","title":"Class variables","text":"<pre><code>nodata_value\n</code></pre> <pre><code>scl_filter\n</code></pre>"},{"location":"api/stacchip/indexer/#instance-variables_5","title":"Instance variables","text":"<pre><code>bbox\n</code></pre> <p>Bounding box that covers all tiles</p> <p>This is different from the bounding box of the STAC item if the tiles don't fit into the number of pixels perfectly.</p> <pre><code>crs\n</code></pre> <p>Get coordinate reference system for the assets in this index</p> <pre><code>size\n</code></pre> <p>Number of tiles in this STAC item</p> <pre><code>x_size\n</code></pre> <p>Number of tiles vailable in x direction</p> <pre><code>y_size\n</code></pre> <p>Number of tiles vailable in y direction</p>"},{"location":"api/stacchip/indexer/#methods_5","title":"Methods","text":""},{"location":"api/stacchip/indexer/#assert_units_metre_5","title":"assert_units_metre","text":"<pre><code>def assert_units_metre(\n    self\n) -&gt; None\n</code></pre> <p>Ensure input data has meters as units</p>"},{"location":"api/stacchip/indexer/#create_index_5","title":"create_index","text":"<pre><code>def create_index(\n    self\n) -&gt; pyarrow.lib.Table\n</code></pre> <p>The index for this STAC item</p>"},{"location":"api/stacchip/indexer/#get_chip_bbox_5","title":"get_chip_bbox","text":"<pre><code>def get_chip_bbox(\n    self,\n    x: int,\n    y: int\n) -&gt; shapely.geometry.polygon.Polygon\n</code></pre> <p>Bounding box for a chip</p>"},{"location":"api/stacchip/indexer/#get_stats_5","title":"get_stats","text":"<pre><code>def get_stats(\n    self,\n    x: int,\n    y: int\n) -&gt; Tuple[float, float]\n</code></pre> <p>Cloud and nodata percentage for a chip</p> <p>Uses the SCL band to compute these values.</p>"},{"location":"api/stacchip/indexer/#reproject_5","title":"reproject","text":"<pre><code>def reproject(\n    self,\n    geom\n) -&gt; shapely._geometry.GeometryType\n</code></pre> <p>Reproject a geometry into WGS84</p>"},{"location":"api/stacchip/indexer/#scl","title":"scl","text":"<pre><code>def scl(\n    ...\n)\n</code></pre> <p>The Scene Classification (SCL) band data for the STAC item</p>"},{"location":"api/stacchip/indexer/#setup_projector_5","title":"setup_projector","text":"<pre><code>def setup_projector(\n    self\n)\n</code></pre> <p>Prepare projection function to project geometries into WGS84</p>"},{"location":"api/stacchip/indexer/#shape_5","title":"shape","text":"<pre><code>def shape(\n    ...\n)\n</code></pre> <p>Shape of the STAC item data</p> <p>Obtains the shape of the highest resolution band from all the available bands.</p>"},{"location":"api/stacchip/indexer/#transform_5","title":"transform","text":"<pre><code>def transform(\n    ...\n)\n</code></pre> <p>The transform property from the STAC item</p>"}]}